<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fundamentos JavaScript</title>
</head>

<body>
  <h1>Fundamentos JavaScritp</h1>
  <h2 style="color: red">Ver Consola para la info</h2>
</body>

<!--! let para declarar variables -->
<script>

  // podemos declarar variables let vacias, es decir sin valor inicial
  let hola;
  console.log(hola);

  // declaramos una variable let con valor inicial
  let alfonso = 'Hola mundo'
  console.log(`La variable Alfonso antes del bloque vale ${alfonso}`)

  /* Ambito de Bloque: para que una varible sea de ambito de bloque es decir que solo sea considerada en un bloque la tienes que declarar con let , es decir, ya no ocupemos var para nada */

  {
    let alfonso = 'alfonso';
    console.log(`La variable Alfonso dentro del bloque vale ${alfonso}`)
  }

  // Si hacemos console.log a la variable fuera del bloque no nos dara nada (ver consola en navegador) O BIEN NOS DARA EL VALOR ANTERIOR DEL BLOQUE

  console.log(`La variable Alfonso despues del bloque vale lo mismo que antes del bloque: ${alfonso}`)
  console.log('%c***************Cambio de tema a const con datos primitivos********************', 'background: #222; color: #bada55')
</script>

<!--! const para declarar constantes -->
<script>

  // const en valores primitivos es decir aquellos que se puede acceder directo a su valor, o sea que no son arreglos u objetos
  const PI = 3.1416
  console.log(`El valor de la const PI es ${PI} este es un valor primitivo (se puede acceder directo a su valor es decir que no es arreglo u objeto) no se puede reasignar, es constante, nunca cambiara su valor`)

  console.log('%c***************const en arreglos u objetos********************', 'background: #222; color: #bada55')

  const objeto = {
    nombre: 'Alfonso',
    edad: 31
  }

  const arregloColores = ["Verde", "Blanco"];

  console.log(`Arrancamos un Objeto declarado unicamente con dos campos `)
  console.log(objeto)
  console.log(`Arrancamos un Array declarado unicamente con dos campos `)
  console.log(arregloColores)

  // const en arreglos u objetos me permite agregar valores al arreglo o al objeto

  objeto.correo = 'alfonso@villanuevagarcia.com';

  arregloColores.push('Rojo')

  console.log(`Agregamos un campo al Objeto `)
  console.log(objeto)
  console.log(`Agregamos un color al Array `)
  console.log(arregloColores)

</script>

<!--! cadenas de texto aka string -->
<script>

  let nombre = 'Alfonso'
  let apellido = "Villanueva"
  let saludo = new String('Que tranza banda como estan?')

  console.log('%c***************trabajando con cadenas de texto aka strings********************', 'background: #222; color: #bada55')
  console.log(`cadena de texto con \'\' simples: ${nombre}`)
  console.log(`cadena de texto con \"\" dobles: ${apellido}`)
  console.log(`cadena de texto con el metodo new String: ${saludo}`)
  console.log(saludo)

  console.log('%c***************la propiedad .length contara el numero de caracteres incluyendo los espacios********************', 'background: #222; color: #bada55')

  console.log(`propiedad .length con la variable nombre: ${nombre.length}`)
  console.log(`propiedad .length con la variable apellido: ${apellido.length}`)
  console.log(`propiedad .length con la variable saludos: ${saludo.length}`)

  // todo metodo lleva () al final de su llamdado por ejemplo toUpperCase()
  console.log('%c***************Metodos toUpperCase() y toLowerCase()********************', 'background: #222; color: #bada55')

  console.log(`Usando el metodo toUpperCase() con la variable nombre ${nombre.toUpperCase()}`)
  console.log(`Usando el metodo toLowerCase() con la variable nombre ${nombre.toLowerCase()}`)

  // el metodo icludes te pide el dato a buscar, por ejemplo variable.includes(alfonso)
  console.log('%c***************Metodo includes()********************', 'background: #222; color: #bada55')

  let nombreCompleto = 'Alfonso Villanueva Quiroz'

  console.log(`La variable nombreCompleto incluye: ${nombreCompleto}`)
  console.log(`Usando el metodo include() veremos si la variable nombreCompleto incluye "Dany": ${nombreCompleto.includes("Dany")}`)
  console.log(`Usando el metodo include() veremos si la variable nombreCompleto incluye "Villanueva": ${nombreCompleto.includes("Villanueva")}`)

  console.log('%c***************Metodo trim()********************', 'background: #222; color: #bada55')

  // el metodo trim "limpia o quita" los espacios antes o despues de cierto parametro
  let nombreEspacios = '    Alfonso    '
  console.log(`El metodo trim "limpia o quita" los espacios antes o despues de cierto parametro, varible nombreEspacios antes del trim: ${nombreEspacios}`)

  console.log(`Variable nombreEspacios con el trim: ${nombreEspacios.trim()}`)

  console.log('%c***************Metodo split()********************', 'background: #222; color: #bada55')

  // el metodo split va a partir un texto en funcion del parametro que le indiquemos
  let lorem = 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Adipisci, beatae commodi. Quisquam perferendis iure amet doloremque cupiditate, dolorum quod perspiciatis vitae nulla natus, odio similique explicabo, fugit repudiandae commodi. Velit?'

  console.log(`Variable lorem antes de hacerle split: ${lorem}`)
  console.log(`Variable lorem con un split por cada espacio que tenga:`)
  console.log(lorem.split(" "))
  console.log(`Variable lorem con un split por cada punto que tenga:`)
  console.log(lorem.split("."))

</script>

<!-- !template strings -->
<script>


  // concatenacion
  console.log('%c***************Concatenacion********************', 'background: #222; color: #bada55')


  console.log("Recoredemos el valor de las variables:")
  console.log(`Nombre ${nombre}`)
  console.log(`Apellido: ${apellido}`)

  console.log(`Formato de concatenacion: "Un string" + variable + "otro string" (Forma aburrida, tediosa y antigua) // Hola mi nombre es " + nombre + " " + apellido + "."`)
  console.log("Resultado de concatenacion: Hola mi nombre es " + nombre + " " + apellido + ".")

  // template string o interpolacion de variables
  console.log('%c***************Template String o Interpolacion de variables  :)********************', 'background: #222; color: #bada55')
  console.log("Formato de Template String:  \`Hola mi nombre es ${nombre} ${apellido}.\` se debe realizar con el backtit ( \` )")
  console.log(`Resultado con Template string: Hola mi nombre es ${nombre} ${apellido}.`)

  let ul = `<ul>
    <li>${nombre}</li>
    <li>${apellido}</li>
    <li>${nombreCompleto}</li>
    <li>${nombreEspacios}</li>
  </ul>`;

  console.log(ul)

</script>

<!-- ! Numeros -->
<script>

  console.log('%c***************Numeros********************', 'background: #222; color: #bada55')

  // hay diferentes formas de declarar un numero en javaScript
  let a = 2
  let b = new Number(4)

  console.log(`Imprimiendo un numero con el formato let a = 2 da como resultado: ${a}`)
  console.log(`Imprimiendo un numero con el formato let b = new Numbre(4)  da como resultado:`)
  console.log(b)

  console.log('%c***************Metodo toFixed()********************', 'background: #222; color: #bada55')

  let c = 32.8654
  console.log(`toFixed va a indicar cuantos decimales tendra un numero por ejemplo la variable let c = 32.8654 sin toFixed() vale: ${c}`)
  console.log(`Vamos a indicarle a la variable c un toFixed(1):`)
  console.log(c.toFixed(1))
  console.log(`Ahora vamos a indicarle a la variable c un toFixed(8):`)
  console.log(c.toFixed(8))

  // parseInt
  console.log('%c***************Metodo parseInt() para numeros********************', 'background: #222; color: #bada55')

  console.log(`Pasaremos la variable let c = 32.8654 en parseInt(c el resultado es:`)
  console.log(parseInt(c))

  let d = "32.5"

  console.log(`valor de let d = "32.5" = ${d}`)
  console.log(`Utilizaremos parseInt(d) para pasar un numero string a un numero de tipo numero, para el ejemplo haremos una suma de c + d`)
  console.log(`suma sin poner parseInt() ` + c + d)
  console.log(`Suma usando parseInt(d): `)
  console.log(parseInt(d) + c)

  console.log('%c**El unico defecto de parseInt() es que solo trae la parte entera, traigamos todo el numero con parseFloat**', 'background: #222; color: #bada55')

  let d2 = "28.6"

  console.log(`Tenemos let d2 = "28.6" cuyo dato por naturaleza es string, con parseFloat lo sumaremos a let c = 32.8654 que es un numero`)
  console.log(parseFloat(d2) + c)

</script>

<!-- ! Valores Booleanos -->
<script>

  let verdadero = true
  let falso = false

</script>

<!-- ! Valores primitivos null NaN y undefined -->
<script>

  console.log('%c***************Valores primitivos null NaN y undefined********************', 'background: #222; color: #bada55')

  // undefined se da principalmente cuando una variable fue iniciada sin valor y que a lo largo de la aplicación no se le ha asignado valor
  let indefinido;
  console.log(`Hemos inicializado una variable sin valor let indefinido; y el varlor de dicha variable es el siguiente: ${indefinido}`)

  // cuando creamos una variable e intencionalmente le asignamos el valor null
  let nulo = null;
  console.log(`cuando creamos una variable e intencionalmente le asignamos el valor null "let nulo = null;" dara como resultado: ${nulo} `)

  // NaN significa Not a Number y nos arrojara este erro cuando la variable no es nun numero

  let noEsUnNumero = 'hola' * 4;
  console.log(`NaN significa Not a Number y nos arrojara este error cuando la variable no es un numero, por ejemplo "let noEsUnNumero = 'hola' * 4;" nos dara el resultado: ${noEsUnNumero}`)

</script>

<!-- ! Funciones -->
<script>
  console.log('%c*************** Funciones ********************', 'background: #222; color: red')

  // una funcion es un bloque de codigo autocontenido que se define una solo vez y puede ser ejecutado en cualquier momento en la app. Opcionalmente, la funcion puede recibir parametros y devolver un valor en funcion de dichos parametros, se dice que las funciones son ciudadanos de primera clase ya que se le puede asignar valores como argumentos y usarse como 

  console.log(`vamos a declarar la funcion alfgow:

   function alfgow() {
    console.log('uno')
    console.log('dos')
    console.log('tres')
  }

  veamos el resultado:`)
  // primero veremos como declarar la funcion

  function alfgow() {
    console.log('uno')
    console.log('dos')
    console.log('tres')
  }

  // ahora ejecutaremos la funcion
  alfgow();

  // funcion que devuelve un valor
  console.log(`vamos a declarar la funcion "funcionQueDevuelveUnValor":

  function funcionQueDevuelveUnValor() {
    console.log('uno')
    console.log('dos')
    console.log('tres')
    return "Esta funcion imprime tres console log"
  }

  veamos el resultado:`)

  function funcionQueDevuelveUnValor() {
    console.log('uno')
    console.log('dos')
    console.log('tres')
    return "Esta funcion imprime tres console log"
  }

  let valorDeLaFuncionConRetur = funcionQueDevuelveUnValor();

  console.log(valorDeLaFuncionConRetur)

  console.log('%c***************Funcion que recibe parametros********************', 'background: #222; color: #bada55')

  console.log(`vamos a declarar la funcion "saludar":

  function saludar(nombre, apellido) {
    console.log(\` Hola nombre y apellido \`)
  }`)


  console.log(`Recordemos el valor de la variable nombre: ${nombre}`)
  console.log(`Recordemos el valor de la variable apellido: ${apellido}`)

  function saludar(nombre, apellido) {
    console.log(`Hola ${nombre} ${apellido}`);
  }

  saludar(nombre, apellido);

</script>

<!-- ! Funciones declaradas vs funciones expresadas -->
<script>

  console.log('%c***************llamado de la funcion declarada antes de ser declarada********************', 'background: #222; color: #bada55')

  declarada()
  console.log('%c*************** Funciones declaradas vs funciones expresadas ********************', 'background: #222; color: red')

  function declarada() {
    console.log(`Una funcion declarada puede invocarse en cualqier parte de la app, incluso antes de que la funcion sea declarada`)
  }

  // funcion anonima
  const funcionExpresada = function () {
    console.log(`Esto es una funcion Expresada, es decir una funcion que se le ha asignado como un valor a una variable, si invocamos esta funcion antes de su definicion, JS nos dira "Error: no se puede acceder a funcionExpresada() antes de ser inicializada" es decir que no se puede ejecutar la funcionExpresada antes de ser declarada.`)
  }

  funcionExpresada()

</script>

<!-- !arreglos -->
<script>
  console.log('%c***************Arreglos********************', 'background: #222; color: #bada55')


  const colores = ["Verde", "Blanco", "Rojo", "Azul"]

  colores.forEach(function (el, index) {
    console.log(`
        <li id=${index}>${el}</li>
    `)

  });
</script>

<!-- !objetos -->
<!-- ?Dentro de un objeto, a las variables se les conoce como atributos o propiedades y a las funciones se les conoce como metodos -->
<script>
  console.log('%c***************Objetos********************', 'background: #222; color: #bada55')

  const objetob = {}
  console.log(objetob)

  const persona = {
    Nombre: "Alfonso",
    Apellido: "Villanueva",
    ApellidoMaterno: "Quiroz",
    Edad: "32 años",
    Pasatiempos: ["Warzone", "Aprender Programacion", "Autos"],
    Soltero: false,
    Contacto: {
      mail: "alfonso@java.com",
      cel: "555555555555",
      twitter: "@alfgow"
    },
    saludar: function () {
      console.log(`Hola`)
    },
    decirMiNombre: function () {
      console.log(`Hola me llamo ${this.Nombre} ${this.Apellido} y me gusta ${this.Pasatiempos}`)
    }
  }

  // la forma de acceder a los atributos de un objeto es: persona.nombre 

  console.log(persona)

  console.log(`El nombre de la persona es: ${persona.nombre}`)

  console.log(`${persona.nombre} es un tipo de ${persona.Edad} que gusta de ${persona.Pasatiempos}`)

  persona.decirMiNombre();

</script>

<!-- !Tipos de operadores -->
<script>

  // Aritmeticos, son los tipicos operadores de suma(+), resta(-), multiplicacion(*) o division (/) y respeta las leyes de signos

  // relacionales: son aquellos comparativos menor que(<), mayor que (>), igual (=),  menor que o igual (<=) mayor que o igual (>=), exactamente igual (===) , diferente de (1=) muy diferente (!==)
  console.log('%c***************Operadores********************', 'background: #222; color: #bada55')

  console.log(7 === 7);
  console.log("7" === 7)

  // operadores de incremento y decremento

  let i = 1;
  console.log(++i)

  // operadores logicos: ! (not), || Or, && And

  console.log(`%c vamos a ocupar ! para cambiar, false a true y true a false`, 'color: yellow')
  console.log(`"console.log(!true)" nos dara false:  ` + !true)
  console.log(`"console.log(!false)" nos dara true:  ` + !false)


  console.log(`%c vamos a ocupar || or para evaluar si alguna de las condiciones se cumple`, 'color: yellow')

  console.log(`Para el ejemplo realizaremos "console.log((9 === 9) || ('9' === 9))" donde estamos diciendo que si numero 9 es identico a numero 9 o cadena de texto 9 es identico a numero 9, como la primer expresion es true, la validacion con OR dira true:`)
  console.log((9 === 9) || ('9' === 9))

  console.log(`%c vamos a ocupar && or para evaluar que todas las condiciones se cumplan`, 'color: yellow')

  console.log(`Para el ejemplo realizaremos "console.log((9 === 9) && ('9' === 9))" donde estamos diciendo que si numero 9 es identico a numero 9 o cadena de texto 9 es identico a numero 9, como la primer expresion es true, la validacion con && dira false ya que la segunda expresion no se cumple:`)

  console.log((9 === 9) && ('9' === 9))

</script>

<!-- !condicionales -->
<script>

  console.log('%c */*/*/ Condicionales  */*/*/*/', 'color:#a5c71b')

  // if else: condicional que nos permite evaluar una expresion y si esta se cumple, ejecutar algo

  let edad = 17;

  console.log(`Veamos el condicional if else, validando si la variable edad es 18 o mayor, actualmente el valor de edad es: ${edad}`)

  if (edad >= 18) {
    console.log(`Bienvenido al table eres mayor de edad`)
  } else {
    console.log(`Vete del table eres menor de edad`)
  }

  // if - else if - else: se les llama if anidado ya que se validan mas de dos expresiones

  console.log('%c */*/*/ If - else ~ if - else if - else  */*/*/*/', 'color:#a5c71b')

  let hora = 9;


  console.log(`Veamos el condicional if - else if - else, validando mas de dos condiciones}
    if (hora >= 0 && hora < 6) {
    console.log("No estes chingando")
  } else if (hora >= 6 && hora < 12) {
    console.log("Gur Morning")
  } else if (hora >= 12 && hora < 19) {
    console.log("Buena tarde")
  } else if (hora >= 19 && hora <= 23) {
    console.log("Buena noche")
  }
  Considerando que "let hora = ${hora}"  
  `)



  if (hora >= 0 && hora < 6) {
    console.log(`No estes chingando`)
  } else if (hora >= 6 && hora < 12) {
    console.log(`Gur Morning`)
  } else if (hora >= 12 && hora < 19) {
    console.log(`Buena tarde`)
  } else if (hora >= 19 && hora <= 23) {
    console.log(`Buena noche`)
  }

  // simplificador del if else : Operador Ternario

  console.log('%c */*/*/ Operador Ternario  */*/*/*/', 'color:#a5c71b')

  console.log(`Para el ejercicio del operador ternario validaremos nuevamente la edad, con la siguiente estructura:

  let mayoriaEdad = (edad<18) ? "Eres menor de edad" : "Eres Mayor de edad"
  
valor de edad: ${edad}
`)

  let mayoriaEdad = (edad < 18) ? "Eres menor de edad" : "Eres Mayor de edad"

  console.log(mayoriaEdad);


  console.log('%c */*/*/ Switch Case  */*/*/*/', 'color:#a5c71b')

  let dia = 5;

  console.log(`Veremos la siguiente estructura de un switch case:
  
   switch (dia) {
    case 0:
      console.log("Es Domingo")
      break;
    case 1:
      console.log("Es Lunes")
      break;
    case 2:
      console.log("Es Martes")
      break;
    case 3:
      console.log("Es Miercoles")
      break;
    case 4:
      console.log("Es Jueves")
      break;
    case 5:
      console.log("Es Viernes")
      break;
    case 6:
      console.log("Es Sabado")
      break;

    default:
      console.log("Error en la fecha")
      break;
  }

  considerando que el valor actual de let dia = ${dia}
  `)

  switch (dia) {
    case 0:
      console.log(`Es Domingo`)
      break;
    case 1:
      console.log(`Es Lunes`)
      break;
    case 2:
      console.log(`Es Martes`)
      break;
    case 3:
      console.log(`Es Miercoles`)
      break;
    case 4:
      console.log(`Es Jueves`)
      break;
    case 5:
      console.log(`Es Viernes`)
      break;
    case 6:
      console.log(`Es Sabado`)
      break;

    default:
      console.log("Error en la fecha")
      break;
  }

</script>

<!-- !Ciclos o bucles -->
<script>

  console.log('%c */*/*/ Ciclos o Bucles  */*/*/*/', 'color:#a5c71b')


  let contador = 0

  console.log(`Primero veremos el While con la siguiente estructura:
  
    while (contador < 10) {
    console.log(contador)
    contador++
  }

  valor de contador: ${contador}

  `)


  while (contador < 10) {
    console.log(contador)
    contador++
  }

  console.log(`Ahora veamos el ciclo for con la siguiente estructura
  
  for (let alfgow = 0; alfgow < 10; alfgow++) {
  console.log(alfgow)
  
}
  
  `)


  for (let alfgow = 0; alfgow < 10; alfgow++) {
    console.log(`La Varibale alfgow tiene el valor ${alfgow}`)

  }

  let numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

  console.log(`Ahora veamos el ciclo for con interaccion de un arreglo:

  let numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90,100]

  el for quedaria de la siguiente manera

  for (let i = 0; i < numeros.length; i++) {
    console.log(numeros[i]);
  }
}
  
  `)

  for (let i = 0; i < numeros.length; i++) {
    console.log(`El arreglo va en ${numeros[i]}`);
  }

  console.log('%c */*/*/ ForIn  */*/*/*/', 'color:#a5c71b')


  const alfgow2 = {
    nombre: "Alfonso",
    apellido: "Villanueva",
    edad: 32
  }

  for (const propiedad in alfgow2) {
    console.log(`key: ${propiedad}, value: ${alfgow2[propiedad]}`)
  }


  console.log('%c */*/*/ ForOf  */*/*/*/', 'color:#a5c71b')

  for (const elemento of numeros) {
    console.log(elemento)
  }

</script>

<!-- ! Manejo de Errores -->
<script>

  console.log('%c */*/*/ Veamos el manejo de errores  */*/*/*/', 'color:#a5c71b')

  console.log(`TryCatch:
  
  try {

    En el Try se agrega el codigo a evaluar

  } catch (error) {

    El catch toma el error que se pueda generar en el codigo a evaluar

  }

  `)

  try {
    let alfgow = 10
    if (isNaN(alfgow)) {
      throw new Error("El dato no es un número")
    }
    console.log(alfgow * alfgow)
  } catch (error) {
    console.log(`Se produjo el siguiente ${error}`)
  }

</script>

<!-- ! Break y continue -->
<script>

  console.log('%c */*/*/ Veamos Break y Continue  */*/*/*/', 'color:#a5c71b')

  // arreglo de 10 digitos
  const numeros2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

  console.log(`Break, utilizaremos el brake para romper un ciclo si se cumple la condicion:
  
  for (let i = 0; i < numeros2.length; i++) {
    if (numeros2 === 5) {
      break
    }
    console.log(numeros2[i])

  }

  `)
  // recorreremos el arreglo con un for
  for (let i = 0; i < numeros2.length; i++) {
    if (i === 5) {
      break
    }
    console.log(numeros2[i])

  }

  console.log(`Ahora, utilizaremos el continue para continuar un ciclo si se cumple la condicion:
  
  for (let i = 0; i < numeros2.length; i++) {
    if (numeros2 === 5) {
      continue
    }
    console.log(numeros2[i])

  }

  `)

  for (let i = 0; i < numeros2.length; i++) {
    if (i === 5) {
      continue
    }
    console.log(numeros2[i])

  }


</script>

<!-- ! Destructuración -->
<script>

  console.log('%c */*/*/ Destructuracion  */*/*/*/', 'color:#a5c71b')
  const numeros3 = [1, 2, 3]

  const [uno, dos, tres] = numeros3
  console.log(uno, dos, tres)

  let persona2 = {
    nombre2: "Alfonso",
    apellido2: "Villanueva",
    edad2: "32"
  }

  let { nombre2, apellido2, edad2 } = persona2
  console.log(nombre2, apellido2, edad2)

</script>

<!-- !Objetos Literales -->
<script>

  console.log('%c */*/*/ Objetos literales  */*/*/*/', 'color:#a5c71b')

  let nombreMascota = 'Sr. Cuyo',
    edadMascota = '3 meses';

  console.log(`Para este ejercicio tendremos las siguientes variables:
    
    let nombreMascota = 'Sr. Cuyo',
    edadMascota = '3 meses';

    en palabras basicas, un Objeto literal es aquel que sus atributos son variables que previamente han sido declaradas,

    En funcion de lo anterior, veamos el objeto literal con la manera antigua de hacerlo

    const mascota = {
    nombre: nombreMascota,
    edad: edadMascota,
    chifla: function () {
      console.log("Fiuuuu fiuuuu")
    }
  }

    `);

  const mascota = {
    nombre: nombreMascota,
    edad: edadMascota,
    chifla: function () {
      console.log("Fiuuuu fiuuuu")
    }
  }
  console.log(mascota)
  mascota.chifla()

  console.log(`Ahora veamos el resultado con la nueva forma que seria:
  
    const cuyo = {
    nombreMascota,
    edadMascota
     chifla () {
      console.log("Fiuuuu fiuuuu")
    }
  }

  notese que JS automaticamente determina el nombre y el valor de los atributos que se le estan dando al objeto y que las funciones carecen de la palabra reservada function, basta con agregar () al parametro

  `);

  const cuyo = {
    nombreMascota,
    edadMascota,
    chifla() {
      console.log("Fiuuuu fiuuuu fiuuuu")
    }
  }

  console.log(cuyo);
  cuyo.chifla()

</script>

<!-- !Parámetros REST & Operador Spread -->
<script>

  console.log('%c */*/*/  Parámetros REST & Operador Spread  */*/*/*/', 'color:#a5c71b')

  console.log(`%c Parametros REST se definen con ...`, `color: red`)
  console.log(`Son una forma de virtualmente ir agregando parametros infinitos a una funcion o una variable, para el ejemplo utilizaremos el siguiente:
  
  function sumarRest(a, ...b) {
    let resultadoSuma = a;

    b.forEach(function (n) {
      resultadoSuma += n
    });

    return resultadoSuma;
  }
  
  `);

  function sumarRest(a, ...b) {
    let resultadoSuma = a;

    b.forEach(function (n) {
      resultadoSuma += n
    });

    return resultadoSuma;
  }

  console.log(sumarRest(5, 5, 5, 5, 5, 5, 5, 5, 5, 5))


  console.log(`%c Spread Operator, tambien se define con  ... pero es una manera de mezclar arreglos en uno solo`, `color: red`)

  console.log(`Para el ejercicio primero definiremos dos arreglos:
  
    const arr1 = [1, 2, 3, 4, 5]
  const arr2 = [6, 7, 8, 9, 0]

  posterioremente con el spread operator ... los mezclaremos en un tercer arreglo

  const arr3 = [...arr1, ...arr2]

  finalmente mostramos resultado
  
  `);

  const arr1 = [1, 2, 3, 4, 5]
  const arr2 = [6, 7, 8, 9, 0]

  const arr3 = [...arr1, ...arr2]

  console.log(arr3);

</script>

<!-- ! Arrow function -->
<script>

  console.log('%c */*/*/  Arrow Function  */*/*/*/', 'color:#a5c71b')

  console.log(`Una arrow Function basicamente es quitar la palabra fuction y porner lo siguiente => por ejemplo:
  
  const saludar = () => {
    console.log("Saludo")

  }

  `);

  console.log(`Solamente cuando la Arrow Function tiene una sola linea de instruccion podemos eliminar los {}
  
  siguiendo con el ejemplo quedaria:

  const saludar = () => console.log("Saludo")
  
  `);

  console.log(`%c para recibir parametros simplemente los pasamos en el parantesis, sin embargo, si solo es un parametro lo podemos pasar sin los parentesis, seguimos con el ejemplo:

  sin parametros lleva parentesis:

  const saludar = () => console.log('Hola')
  
  con dos o mas parametros:

  const saludar = (nombre, apellido) => console.log(\`Hola ${nombre}, ${apellido}\`)

  con un solo parametro - sin parentesis

  const saludar = nombre => console.log(\` Hola ${nombre} \`)
  
  
  `, `color: yellow`);

  const saludarConArrowFunction = nombre => console.log(`hola ${nombre}`)

  saludarConArrowFunction('Poncho')


  console.log(`%c Las Arrow Function tambien tienen el return implicito, por ejmplo el ejercicio  de las sumas:
  
   const sumar = function(a+b) {
     return a+b
   }

   con Arrow Function quedaria de la siguiente manera - sin Return

   const sumarConArrowFunction = (a,b) => a+b

  `, `color: pink`);

  const sumarConArrowFunction = (a, b) => a + b

  console.log(sumarConArrowFunction(9, 9));

  console.log(`Aun con las Arrow Function, si la funcion lleva dos o mas lineas de instruccion debemos poner {} para el ejmplo veamos:

      const arrowFunctionVariasLineas = () => {
    console.log('Que');
    console.log('Tranza');
    console.log('Banda');
    console.log('Como');
    console.log('Estan');
  }
  
  `);

  const arrowFunctionVariasLineas = () => {
    console.log(`Que`);
    console.log(`Tranza`);
    console.log(`Banda`);
    console.log(`Como`);
    console.log(`Estan`);
  }

  arrowFunctionVariasLineas()


  console.log(`Utilizando las Arrow Function para iterar con los arreglos con el metodo forEach, veamos el siguiente ejemplo:
  
  const numerosArrowFunction = [1, 2, 3, 4, 5, 6, 7, 8]

  numerosArrowFunction.forEach(el, index) => console.log("El elemento EL esta en la posicion INDEX")
  
  `);


  const numerosArrowFunction = [1, 2, 3, 4, 5, 6, 7, 8];

  numerosArrowFunction.forEach((el, index) => console.log(`El elemento ${el} esta en la posicion ${index}`))

  console.log(`%c Las Arrow Function captura el objeto this del contexto en el que se encuentren, por lo tanto no es recomendable hacer lo siguiente`, `color: yellow`);
  console.log(`Para el ejemplo veamos:
  
manera function en un objeto literal:

  const cuyo = {
    nombre: 'Sr. Cuyo',
    chiflar () {
      console.log(this)
    }
  }

Con Arrow Function - no recomendable:

const cuyo = {
    nombre: 'Sr. Cuyo',
    chiflar: () => {
      console.log(this)
    }
  }

  
  `);


  const cuyoArrow = {
    nombre: 'Sr. Cuyo',
    chiflar: function () {
      console.log(this)
    }
  }

  cuyoArrow.chiflar();

</script>

<!-- !  Programacion Orientada a Objetos -->
<script>

  // POO
  /*
  
  Clases - Modelo a Seguir
   |---->Objetos - Instancias de una clase
               |------>Atributos - Son las caracteristicas o propiedades de los objetos
               |------>Metodos - Acciones que un objeto puede realizar (funciones dentro de un objeto)

  */

  console.log(`%c PROGRAMACION ORIENTADA A OBJETOS`, `color: yellow`);
  console.log(`%c Declaremos una Funcion constructora`, `color: red`);
  console.log(`Las clases siempre se declaran con UpperCamelCase, por ejemplo class SerHumano`);
  console.log(`En las Funciones Constructoras, para declarar un metodo de la funcion debemos utilizar .this, no aplica la forma de los objetos literales, por lo que tenemos que usar la palabra reservada function anonima, veamos el ejemplo

  // funcion constructora
function Animal(nombre, genero) {

    // atributos
    this.nombre = nombre;
    this.genero = genero;

    // metodo
    this.sonar = function () {
      console.log('Hago sonidos por que estoy vivo');
    }
  }

  despues de declarar la funcion Constructora vamos a utilizarlo con dos ejemplos:

   const snoopy = new Animal("Snoopy", "Perro"),
    lolaBunny = new Animal("Lola Bunny", "Conejo")
  
    Sin embargo es completamente recomendable asignar los metodos al prototipo y no a la funcion constructora

    
  `);

  // funcion constructora
  function Animal(nombre, tipo) {

    // atributos
    this.nombre = nombre;
    this.tipo = tipo;

  }

  // Metodos agregados al prototipo de la funcion constructora
  Animal.prototype.sonar = function () {
    console.log(`Hago sonidos por que estoy vivo`);
  }

  Animal.prototype.saludar = function () {
    console.log(`Hola Me llamo ${this.nombre}`);
  }

  // utilizando la funcion constructora
  const snoopy = new Animal("Snoopy", "Perro"),
    lolaBunny = new Animal("Lola Bunny", "Conejo")

  console.log(snoopy);
  console.log(lolaBunny);

  // utilizando los Metodos agregados al prototipo de la funcion constructora
  snoopy.sonar()
  snoopy.saludar()
  lolaBunny.sonar()
  lolaBunny.saludar()

  // Herencia Prototipica
  console.log(`Para la Herencia Prototipica, vamos a generar una funcion constructora para crear un perro, prototipo que heredara las caracteristicas de la funcion constructora Animal, con el elemento super vamos a llamar el constructor de la clase padre, veamos el ejemplo
  

  
  `);

  function Perro(nombre, tipo, size) {
    this.super = Animal;
    this.super(nombre, tipo);
    this.size = size;
  }

  // perro esta heredando de animal
  Perro.prototype = new Animal()
  Perro.prototype.constructor = Perro

  // sobreescritura de los metodos del prototipo padre en el hijo

  Perro.prototype.sonar = () => console.log(`Soy un perro y hago guauuuu`);

  Perro.prototype.ladrar = () => console.log(`guauuu guauuu`);

  const frank = new Perro('Frank', 'Macho', 'Chico')

  console.log(frank);

  frank.sonar();
  frank.ladrar();

</script>

<!-- ? Seguir en minuto 11 del video de Curso JavaScript: 22. Prototipos -->


</html>